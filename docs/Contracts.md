# Система контрактов и канонизации Faravel

Эта система предназначена для устранения путаницы в публичных API классов и
для исключения самодеятельности при добавлении методов. Она определяет
стандарт оформления «контракта» класса в шапке каждого PHP‑файла и регламент
изменения этих контрактов.

## Зачем это нужно

Сегодня в проекте множество классов разрослось без единого стандарта: где‑то
методы копируются, где‑то — отсутствуют, появляются неожиданные побочные
эффекты. Ясная документация прямо в файле помогает быстро понять назначение
класса и его публичный API. Контракты также позволяют инструментировать
проверку в CI: любой новый или изменённый метод обязан сопровождаться
обновлением контракта, иначе сборка будет падать.

## Формат шапки файла

Каждый PHP‑файл с определением класса должен начинаться с блока комментария,
описанного ниже. Блок состоит из 3 частей: `Purpose`, `FIX` и `Contract`.

```php
<?php // vX.Y.Z
/* path/to/Class.php
Purpose: краткое назначение класса/файла (1‑2 предложения).
FIX: краткое описание последнего изменения.

Contract:
  - methodName(Type $param, ?Type2 $optional = null): ReturnType
    Предусловия: …
    Побочные эффекты: …
    Исключения: …
  - …
*/
```

**Правила:**

- В `Contract` перечисляются **все публичные методы** класса. Для каждого
  метода указывайте сигнатуру (типы параметров и возврата), предусловия,
  побочные эффекты (запись в базу, изменение сессии, вызов сторонних API и
  т. п.) и возможные исключения. Это помогает понять, что ожидается от
  вызывающей стороны и чего не будет.
- Для сложных типов используйте строгую типизацию: `?Type`, `array{key:Type}`,
  `iterable<Type>` и т. п. Допускается давать ссылку на отдельный раздел
  глоссария, если тип сложный.
- В `FIX` кратко поясните цель последней правки. Например: «исправлен
  некорректный редирект в главном маршруте», «добавлена проверка ввода».
- Если у класса нет публичных методов (например, миграция или провайдер), в
  `Contract` достаточно указать «нет публичных методов».

## Процесс изменения API

1. **Планирование.** Перед добавлением или изменением публичного метода
   обсудите задачу в issue/пуле: почему нужен новый метод, какие
   предусловия и эффекты.
2. **Обновите контракт.** Внесите изменение в блок `Contract` в шапке файла,
   добавив новую подпись или изменив существующую. Обновите `@param`/`@return`
   в PHPDoc метода.
3. **Реализуйте код.** Реализуйте или измените метод в соответствии с
   контрактом. Следуйте стилю оформления (PSR‑12) и используйте строгие
   типы.
4. **Проведите код‑ревью.** Проверяющий смотрит, синхронизированы ли код и
   контракт. Если контракт не обновлён — PR отклоняется.
5. **Обновите журнал изменений.** Отметьте изменения в `CHANGELOG.md`.

## Двухэтапный план канонизации

Внедрение контрактов во всём коде — крупная задача, поэтому предлагается
разделить её на два этапа:

### Шаг 1. Обязательное требование для новых и изменяемых файлов

Начиная с версии, в которой внедряется эта система, **каждый новый файл или
любой файл, который вы модифицируете**, должен иметь шапку с контрактом.
Ревьюеры внимательно следят за выполнением требования. На этом этапе не
требуется мгновенно покрыть все старые файлы — это слишком трудоёмко.

### Шаг 2. Полное покрытие и автоматизация

Параллельно с разработкой по мере возможностей берите старые файлы и
добавляйте им шапки. Когда весь код будет покрыт, подключите простой
скрипт или статический анализатор в CI, который проверяет:

- Наличие блока `Contract:` в начале каждого PHP‑файла.
- Совпадение списка публичных методов в коде и в контракте.
- Наличие PHPDoc с аннотациями `@param`, `@return` и `@throws` у всех
  публичных методов.

После успешного прохождения этих проверок можно считать систему
канонизации завершённой. С этого момента добавление методов без обновления
контракта будет считаться ошибкой сборки.

## Разрешение на добавление методов

Разработчики **могут добавлять новые методы** в классы, но **обязаны
одновременно обновлять контракт**. Добавление метода без обновления
контракта приводит к ошибке CI. Этот процесс гарантирует, что API класса
остается прозрачным и согласованным для всей команды.

## Контрактные интерфейсы

Чтобы программисты имели не только текстовое описание в шапке файла,
но и готовые каркасы, в каталоге `app/Contracts` выделены несколько
интерфейсов. Они определяют минимальный набор методов для основных
слоёв приложения и позволяют IDE и статическому анализатору сразу
контролировать соответствие сигнатур. На данный момент доступны:

- `App\\Contracts\\Http\\Controller\\InvokableControllerContract` — базовый
  контракт для «одноразовых» контроллеров (actions). Требует наличие
  метода `__invoke(Request $request, ...$params): Response` и гарантирует,
  что контроллер не будет сам выполнять отправку ответа или вызывать exit.
- `App\\Contracts\\Service\\ServiceContract` — базовый контракт для
  сервисов. Предписывает наличие метода `execute(array $data): mixed` и
  описывает общие ожидания от входных данных и побочных эффектов.
- `App\\Contracts\\ViewModel\\ViewModelContract` — уже существующий
  контракт для ViewModel; требует метода `toArray(): array`, возвращающего
  готовые для Blade данные без побочных эффектов.

Использование этих интерфейсов не является жёстким требованием для
старого кода, однако для всех новых классов рекомендуется либо
реализовывать соответствующий контракт, либо ссылаться на него в
аннотациях PHPDoc. Это создаст единый язык для всей команды и упростит
поиск и переиспользование кода.

---

Следуя этому документу, команда Faravel сможет поддерживать единообразие
кода и избежать неожиданностей при использовании классов. Контракты —
это не «лишняя бумажная работа», а инструмент повышения качества и
предсказуемости приложения.